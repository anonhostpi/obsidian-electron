/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => VarePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/settings/SettingsTab.ts
var import_obsidian4 = require("obsidian");

// src/constants.ts
var ICON_ACCEPT = "check";
var ICON_DENY = "x";
var ICON_ADD = "plus";
var ICON_RELOAD = "refresh-cw";
var ICON_INSTALL = "download";
var ICON_GITHUB = "github";
var ICON_FIX = "wrench";
var ICON_RESET = "loader";
var ICON_FETCH = "download-cloud";

// src/modals/PluginDataModal.ts
var import_obsidian2 = require("obsidian");

// src/util/GitHub.ts
var import_obsidian = require("obsidian");
var repositoryRegEx = /^[a-z\d](?:[a-z\d]|-(?=[a-z\d])){0,38}\/[A-Za-z0-9_.-]+$/i;
async function fetchCommmunityPluginList() {
  const URL = "https://raw.githubusercontent.com/obsidianmd/obsidian-releases/HEAD/community-plugins.json";
  try {
    const response = await (0, import_obsidian.request)({ url: URL });
    return await JSON.parse(response);
  } catch (e) {
    e.message = "Failed to fetch community plugin list! " + e.message;
    console.error(e);
  }
}
async function fetchReleases(repository) {
  const URL = `https://api.github.com/repos/${repository}/releases`;
  try {
    if (!repositoryRegEx.test(repository)) {
      throw Error("Repository string do not match the pattern!");
    }
    const response = await (0, import_obsidian.request)({ url: URL });
    const data = await JSON.parse(response);
    const releases = data.map((value) => {
      var _a;
      return {
        tag_name: value.tag_name,
        prerelease: value.prerelease,
        manifest_url: (_a = value.assets.find((asset) => asset.name === "manifest.json")) == null ? void 0 : _a.browser_download_url
      };
    });
    return releases;
  } catch (e) {
    e.message = "Failed to fetch releases for plugin! " + e.message;
    console.error(e);
  }
}
async function fetchManifest(repository, tag_name, url) {
  url = url ? url : `https://raw.githubusercontent.com/${repository}/${tag_name ? tag_name : "HEAD"}/manifest.json`;
  try {
    if (repository && !repositoryRegEx.test(repository)) {
      throw Error("Repository string do not match the pattern!");
    }
    const response = await (0, import_obsidian.request)({ url });
    return await JSON.parse(response);
  } catch (e) {
    e.message = "Failed to fetch the manifest for plugin! " + e.message;
    console.error(e);
  }
}

// src/modals/PluginDataModal.ts
var PluginDataModal = class extends import_obsidian2.Modal {
  constructor(plugin, onSubmit) {
    super(plugin.app);
    this.plugin = plugin;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    let username;
    let repository;
    this.setTitle("Profile options");
    new import_obsidian2.Setting(contentEl).setName("Github username").setDesc("The name of the owner of the plugin").addText((text) => text.setPlaceholder("Username").onChange((value) => {
      username = value;
    }));
    new import_obsidian2.Setting(contentEl).setName("Github repository").setDesc("The name of the repository of the plugin").addText((text) => text.setPlaceholder("Repository").onChange((value) => {
      repository = value;
    }));
    new import_obsidian2.Setting(contentEl).addButton((button) => button.setButtonText("Save").onClick(async () => {
      if (!username || username === "") {
        new import_obsidian2.Notice("Github username cannot be empty!");
        return;
      }
      if (!repository || repository === "") {
        new import_obsidian2.Notice("Github repository cannot be empty!");
        return;
      }
      const repo = `${username}/${repository}`;
      if (!repositoryRegEx.test(repo)) {
        new import_obsidian2.Notice("Github <username>/<repository> do not match the pattern!");
        return;
      }
      const releases = await fetchReleases(repo);
      if (!releases || releases.length <= 0) {
        new import_obsidian2.Notice("No releases found for this plugin. May it do not have any.");
        return;
      }
      const manifest = await fetchManifest(void 0, void 0, releases[0].manifest_url) || await fetchManifest(repo, releases[0].tag_name) || await fetchManifest(repo);
      if (!manifest) {
        new import_obsidian2.Notice("Github repository could not be found!");
        return;
      }
      const pluginInfo = Object.assign({}, manifest, { repo, releases });
      pluginInfo.targetVersion = pluginInfo.version;
      pluginInfo.version = "";
      this.onSubmit(pluginInfo);
      this.close();
    })).addButton((button) => button.setButtonText("Cancel").setWarning().onClick(() => {
      this.close();
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/modals/PluginTroubleshootingModal.ts
var import_obsidian3 = require("obsidian");
var PluginTroubleshootingModal = class extends import_obsidian3.Modal {
  constructor(plugin, pluginInfo, onSubmit) {
    super(plugin.app);
    this.plugin = plugin;
    this.pluginInfo = structuredClone(pluginInfo);
    this.onSubmit = onSubmit;
  }
  async onOpen() {
    const { contentEl } = this;
    let username = this.pluginInfo.repo.split("/").at(0) || "";
    let repository = this.pluginInfo.repo.split("/").at(1) || "";
    let manifest;
    let hasManifest = false;
    let releases;
    let hasReleases = false;
    const updateRepo = (0, import_obsidian3.debounce)(() => {
      this.pluginInfo.repo = `${username}/${repository}`;
      this.update();
    }, 1500, true);
    this.setTitle(`Troubleshoot plugin ${this.pluginInfo.name}`);
    new import_obsidian3.Setting(contentEl).setName("Github username").setDesc("The name of the owner of the plugin").addText((text) => text.setPlaceholder("Username").setValue(username).onChange((value) => {
      username = value;
      updateRepo();
    }));
    new import_obsidian3.Setting(contentEl).setName("Github repository").setDesc("The name of the repository of the plugin").addText((text) => text.setPlaceholder("Repository").setValue(repository).onChange((value) => {
      repository = value;
      updateRepo();
    }));
    new import_obsidian3.Setting(contentEl).setName("Test pattern").setDesc(repositoryRegEx.test(this.pluginInfo.repo) ? "" : "Username or repository contains invalid input.").addExtraButton((button) => button.setIcon(repositoryRegEx.test(this.pluginInfo.repo) ? ICON_ACCEPT : ICON_DENY).setTooltip(repositoryRegEx.test(this.pluginInfo.repo) ? "" : "Try again?").setDisabled(repositoryRegEx.test(this.pluginInfo.repo)).onClick(() => {
      this.update();
    }));
    if (repositoryRegEx.test(this.pluginInfo.repo)) {
      manifest = await fetchManifest(this.pluginInfo.repo);
      hasManifest = manifest !== void 0;
      new import_obsidian3.Setting(contentEl).setName("Test connection").setDesc(hasManifest ? "" : "Repo could not be found on GitHub. Is everything typed correctly?").addExtraButton((button) => button.setIcon(hasManifest ? ICON_ACCEPT : ICON_DENY).setTooltip(hasManifest ? "" : "Try again?").setDisabled(hasManifest).onClick(() => {
        this.update();
      }));
    }
    if (hasManifest) {
      releases = await fetchReleases(this.pluginInfo.repo);
      hasReleases = releases !== void 0 && releases.length > 0;
      new import_obsidian3.Setting(contentEl).setName("Test releases").setDesc(hasReleases ? "" : "Could not find releases on GitHub. May this plugin did not have any.").addExtraButton((button) => button.setIcon(hasReleases ? ICON_ACCEPT : ICON_DENY).setTooltip(hasReleases ? "" : "Try again?").setDisabled(hasReleases).onClick(() => {
        this.update();
      }));
    }
    new import_obsidian3.Setting(contentEl).addButton((button) => button.setButtonText("Save").setDisabled(!repositoryRegEx.test(this.pluginInfo.repo) || !hasManifest).onClick(async () => {
      if (hasReleases && releases) {
        this.pluginInfo.releases = releases;
        this.pluginInfo.lastFetch = new Date();
      }
      this.onSubmit(this.pluginInfo);
      this.close();
    })).addButton((button) => button.setButtonText("Cancel").setWarning().onClick(() => {
      this.close();
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  update() {
    this.onClose();
    this.onOpen();
  }
};

// src/settings/SettingsTab.ts
var VareSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.loadPluginList();
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    const communityList = await fetchCommmunityPluginList();
    Promise.all(this.pluginsList.map(async (value) => {
      const now = new Date();
      if (!value.lastFetch || now.getTime() - 1e3 * 60 * 60 * 12 >= new Date(value.lastFetch).getTime()) {
        if (value.repo === "") {
          const community = communityList == null ? void 0 : communityList.find((community2) => community2.id === value.id);
          if (!community) {
            return;
          }
          value.repo = community.repo;
        }
        const releases = await fetchReleases(value.repo);
        if (!releases) {
          return;
        }
        value.lastFetch = now;
        value.releases = releases;
      }
      const data = {
        id: value.id,
        repo: value.repo,
        targetVersion: value.targetVersion,
        releases: value.releases,
        lastFetch: value.lastFetch
      };
      this.plugin.settings.plugins[value.id] = data;
    })).then(async () => {
      await this.plugin.saveSettings();
    }).then(() => {
      new import_obsidian4.Setting(containerEl).setHeading().setName("Plugins").addExtraButton((button) => button.setIcon(ICON_ADD).setTooltip("Add unlisted plugin").onClick(() => {
        new PluginDataModal(this.plugin, (result) => {
          this.pluginsList.push(result);
          this.display();
        }).open();
      })).addExtraButton((button) => button.setIcon(ICON_RELOAD).setTooltip("Reload plugins").onClick(() => {
        this.loadPluginList();
        this.display();
      }));
      this.pluginsList.forEach((plugin) => {
        let versions = {};
        if (plugin.releases.length > 0) {
          plugin.releases.forEach((element) => {
            if (element.tag_name) {
              const key = element.tag_name;
              const value = element.tag_name;
              versions = Object.assign(versions, { [key]: value });
            }
          });
        }
        let trouble = false;
        const settings = new import_obsidian4.Setting(containerEl.createEl("div", { cls: "plugins-container" })).setName(plugin.name).setDesc(createFragment((fragment) => {
          fragment.append(`Installed version: ${plugin.version}`, fragment.createEl("br"), `Author: ${plugin.author}`);
        }));
        if (plugin.repo) {
          settings.addExtraButton((button) => button.setIcon(ICON_GITHUB).setTooltip("Open at GitHub").onClick(async () => {
            self.open(`https://github.com/${plugin.repo}`);
          })).addExtraButton((button) => button.setIcon(ICON_FETCH).setTooltip("Fetch releases").onClick(async () => {
            const releases = await fetchReleases(plugin.repo);
            if (!releases) {
              return;
            }
            plugin.lastFetch = new Date();
            plugin.releases = releases;
            this.display();
          }));
        } else {
          trouble = true;
        }
        settings.addExtraButton((button) => button.setIcon(ICON_RESET).setTooltip("Reset version").onClick(async () => {
          delete plugin.targetVersion;
          this.display();
        }));
        if (plugin.releases.length > 0) {
          settings.addDropdown((dropdown) => dropdown.addOptions(versions).setValue(plugin.targetVersion || "").onChange((value) => {
            plugin.targetVersion = value;
            this.display();
          }));
        } else {
          trouble = true;
        }
        if (trouble) {
          settings.addButton((button) => button.setIcon(ICON_FIX).setTooltip("Troubleshoot plugin.").setWarning().onClick(() => {
            new PluginTroubleshootingModal(this.plugin, plugin, (result) => {
              this.pluginsList.every((value, index, array) => {
                if (value.id === result.id) {
                  array[index] = result;
                  return false;
                }
                return true;
              });
              this.display();
            }).open();
          }));
        }
        if (plugin.targetVersion && plugin.version !== plugin.targetVersion) {
          settings.addExtraButton((button) => button.setIcon(ICON_INSTALL).setTooltip("Install version").onClick(async () => {
            var _a;
            try {
              const manifest_url = (_a = plugin.releases.find((release) => release.tag_name === plugin.targetVersion)) == null ? void 0 : _a.manifest_url;
              const manifest = await fetchManifest(void 0, void 0, manifest_url) || await fetchManifest(plugin.repo, plugin.targetVersion) || await fetchManifest(plugin.repo);
              if (!manifest) {
                throw Error("No manifest found for this plugin!");
              }
              if (!manifest.dir) {
                manifest.dir = this.app.vault.configDir + "/plugins/" + plugin.id;
              }
              const version = plugin.targetVersion || manifest.version;
              if (!version) {
                throw Error("Manifest do not contain a version!");
              }
              await this.plugin.app.plugins.installPlugin(plugin.repo, version, manifest);
              const installed = this.plugin.app.plugins.manifests[plugin.id];
              if (!installed) {
                throw Error("Installation failed!");
              }
              plugin.version = installed.version;
              const data = {
                id: plugin.id,
                repo: plugin.repo,
                targetVersion: plugin.targetVersion,
                releases: plugin.releases,
                lastFetch: plugin.lastFetch
              };
              this.plugin.settings.plugins[plugin.id] = data;
              await this.plugin.saveSettings();
              this.display();
            } catch (e) {
              e.message = "Failed to install plugin! " + e.message;
              console.error(e);
            }
          }));
        }
      });
    });
  }
  loadPluginList() {
    const manifests = Object.entries(structuredClone(this.plugin.app.plugins.manifests));
    const pluginData = Object.entries(structuredClone(this.plugin.settings.plugins));
    const upToDate = pluginData.filter((data) => !manifests.every((entry) => data[0] !== entry[0]));
    this.plugin.settings.plugins = {};
    upToDate.forEach((plugin) => {
      this.plugin.settings.plugins[plugin[0]] = plugin[1];
    });
    this.pluginsList = manifests.map((manifest) => {
      const info = { ...manifest[1], repo: "", releases: [] };
      const data = upToDate.filter((data2) => data2[0] === manifest[0])[0];
      if (!data) {
        return info;
      }
      return Object.assign(info, data[1]);
    });
  }
};

// src/settings/SettingsInterface.ts
var DEFAULT_SETTINGS = {
  plugins: {}
};

// src/main.ts
var VarePlugin = class extends import_obsidian5.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new VareSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
